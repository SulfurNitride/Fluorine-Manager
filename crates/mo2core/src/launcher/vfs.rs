//! VFS path translation for launching executables through the FUSE mount.
//!
//! When VFS is mounted at `<instance>/VFS_FUSE/`, executables and working
//! directories need their paths translated from real filesystem locations
//! to VFS equivalents. This module handles three cases:
//!
//! 1. Exe inside the game directory → `VFS_FUSE/<relative_path>`
//! 2. Exe inside a mod's `Root/` folder → `VFS_FUSE/<relative_to_Root>`
//! 3. External tool → path unchanged (tool still sees VFS via data dir args)

use std::path::{Path, PathBuf};

use crate::instance::Instance;
use crate::rootbuilder;

fn strip_prefix_flexible(path: &Path, base: &Path) -> Option<PathBuf> {
    if let Ok(relative) = path.strip_prefix(base) {
        return Some(relative.to_path_buf());
    }

    let canonical_path = std::fs::canonicalize(path).ok()?;
    let canonical_base = std::fs::canonicalize(base).ok()?;
    canonical_path
        .strip_prefix(&canonical_base)
        .ok()
        .map(Path::to_path_buf)
}

/// Translate an executable path to its VFS equivalent.
///
/// Returns the translated path if the exe is inside the game directory
/// or a mod's `Root/` folder. Returns the original path if it's an
/// external tool not covered by the VFS.
pub fn translate_exe_to_vfs(
    exe_path: &Path,
    game_dir: &Path,
    mount_point: &Path,
    instance: &Instance,
) -> PathBuf {
    // Case 1: Exe is inside the game directory (e.g., SkyrimSE.exe, CreationKit.exe)
    if let Some(relative) = strip_prefix_flexible(exe_path, game_dir) {
        return mount_point.join(relative);
    }

    // Case 2: Exe is inside a mod's Root/ folder (e.g., SKSE/Root/skse64_loader.exe)
    if let Some(relative) = rootbuilder::redirect_executable(exe_path, instance) {
        return mount_point.join(relative);
    }

    // Case 3: External tool — keep original path
    exe_path.to_path_buf()
}

/// Translate a working directory path to its VFS equivalent.
///
/// If the working directory is inside the game directory, it's remapped
/// to the VFS mount point. Otherwise, it's returned unchanged.
pub fn translate_working_dir_to_vfs(
    working_dir: &Path,
    game_dir: &Path,
    mount_point: &Path,
) -> PathBuf {
    if let Some(relative) = strip_prefix_flexible(working_dir, game_dir) {
        mount_point.join(relative)
    } else {
        working_dir.to_path_buf()
    }
}

/// Check if an executable path is inside the game directory or a mod's Root/.
///
/// Useful for deciding whether to set the VFS mount point as the working
/// directory when the exe doesn't have one explicitly configured.
pub fn is_vfs_executable(exe_path: &Path, game_dir: &Path, instance: &Instance) -> bool {
    strip_prefix_flexible(exe_path, game_dir).is_some()
        || rootbuilder::redirect_executable(exe_path, instance).is_some()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::instance::create_instance;

    fn make_test_instance(tmp: &Path) -> Instance {
        let root = tmp.join("instance");
        create_instance(&root, "Skyrim Special Edition").unwrap();

        let mods_dir = root.join("mods");

        // Mod with Root/ containing an exe
        let mod_skse = mods_dir.join("SKSE");
        std::fs::create_dir_all(mod_skse.join("Root")).unwrap();
        std::fs::write(mod_skse.join("Root/skse64_loader.exe"), "skse").unwrap();

        // Mod without Root/
        let mod_tex = mods_dir.join("TextureMod");
        std::fs::create_dir_all(mod_tex.join("textures")).unwrap();
        std::fs::write(mod_tex.join("textures/sky.dds"), "tex").unwrap();

        let modlist = "# This file was automatically generated by Mod Organizer.\r\n\
            +SKSE\r\n\
            +TextureMod\r\n";
        std::fs::write(root.join("profiles/Default/modlist.txt"), modlist).unwrap();

        Instance::load(&root).unwrap()
    }

    #[test]
    fn test_translate_exe_in_game_dir() {
        let game_dir = Path::new("/games/Skyrim");
        let mount = Path::new("/instance/VFS_FUSE");
        let tmp = tempfile::tempdir().unwrap();
        let instance = make_test_instance(tmp.path());

        let exe = Path::new("/games/Skyrim/SkyrimSE.exe");
        let result = translate_exe_to_vfs(exe, game_dir, mount, &instance);
        assert_eq!(result, PathBuf::from("/instance/VFS_FUSE/SkyrimSE.exe"));
    }

    #[test]
    fn test_translate_exe_in_game_subdir() {
        let game_dir = Path::new("/games/Skyrim");
        let mount = Path::new("/instance/VFS_FUSE");
        let tmp = tempfile::tempdir().unwrap();
        let instance = make_test_instance(tmp.path());

        let exe = Path::new("/games/Skyrim/CreationKit/CreationKit.exe");
        let result = translate_exe_to_vfs(exe, game_dir, mount, &instance);
        assert_eq!(
            result,
            PathBuf::from("/instance/VFS_FUSE/CreationKit/CreationKit.exe")
        );
    }

    #[test]
    fn test_translate_exe_in_mod_root() {
        let game_dir = Path::new("/games/Skyrim");
        let tmp = tempfile::tempdir().unwrap();
        let instance = make_test_instance(tmp.path());
        let mount = Path::new("/instance/VFS_FUSE");

        // The exe is inside the SKSE mod's Root/ folder
        let exe = instance.mods_dir().join("SKSE/Root/skse64_loader.exe");
        let result = translate_exe_to_vfs(&exe, game_dir, mount, &instance);
        assert_eq!(
            result,
            PathBuf::from("/instance/VFS_FUSE/skse64_loader.exe")
        );
    }

    #[test]
    fn test_translate_external_exe_unchanged() {
        let game_dir = Path::new("/games/Skyrim");
        let mount = Path::new("/instance/VFS_FUSE");
        let tmp = tempfile::tempdir().unwrap();
        let instance = make_test_instance(tmp.path());

        let exe = Path::new("/usr/bin/loot");
        let result = translate_exe_to_vfs(exe, game_dir, mount, &instance);
        assert_eq!(result, PathBuf::from("/usr/bin/loot"));
    }

    #[test]
    fn test_translate_working_dir_in_game() {
        let game_dir = Path::new("/games/Skyrim");
        let mount = Path::new("/instance/VFS_FUSE");

        let wd = Path::new("/games/Skyrim/Data");
        let result = translate_working_dir_to_vfs(wd, game_dir, mount);
        assert_eq!(result, PathBuf::from("/instance/VFS_FUSE/Data"));
    }

    #[test]
    fn test_translate_working_dir_external() {
        let game_dir = Path::new("/games/Skyrim");
        let mount = Path::new("/instance/VFS_FUSE");

        let wd = Path::new("/home/user/tools");
        let result = translate_working_dir_to_vfs(wd, game_dir, mount);
        assert_eq!(result, PathBuf::from("/home/user/tools"));
    }

    #[test]
    fn test_is_vfs_executable_game_dir() {
        let game_dir = Path::new("/games/Skyrim");
        let tmp = tempfile::tempdir().unwrap();
        let instance = make_test_instance(tmp.path());

        assert!(is_vfs_executable(
            Path::new("/games/Skyrim/SkyrimSE.exe"),
            game_dir,
            &instance,
        ));
    }

    #[test]
    fn test_is_vfs_executable_mod_root() {
        let tmp = tempfile::tempdir().unwrap();
        let instance = make_test_instance(tmp.path());
        let game_dir = Path::new("/games/Skyrim");

        let exe = instance.mods_dir().join("SKSE/Root/skse64_loader.exe");
        assert!(is_vfs_executable(&exe, game_dir, &instance));
    }

    #[test]
    fn test_is_vfs_executable_external() {
        let game_dir = Path::new("/games/Skyrim");
        let tmp = tempfile::tempdir().unwrap();
        let instance = make_test_instance(tmp.path());

        assert!(!is_vfs_executable(
            Path::new("/usr/bin/loot"),
            game_dir,
            &instance,
        ));
    }

    #[cfg(unix)]
    #[test]
    fn test_translate_exe_symlinked_game_dir() {
        use std::os::unix::fs::symlink;

        let tmp = tempfile::tempdir().unwrap();
        let real_game = tmp.path().join("real_game");
        std::fs::create_dir_all(&real_game).unwrap();
        let exe = real_game.join("SkyrimSE.exe");
        std::fs::write(&exe, "bin").unwrap();

        let game_link = tmp.path().join("game_link");
        symlink(&real_game, &game_link).unwrap();

        let mount = Path::new("/instance/VFS_FUSE");
        let instance = make_test_instance(tmp.path());
        let translated = translate_exe_to_vfs(&exe, &game_link, mount, &instance);
        assert_eq!(translated, PathBuf::from("/instance/VFS_FUSE/SkyrimSE.exe"));
    }

    #[cfg(unix)]
    #[test]
    fn test_translate_working_dir_symlinked_game_dir() {
        use std::os::unix::fs::symlink;

        let tmp = tempfile::tempdir().unwrap();
        let real_game = tmp.path().join("real_game");
        let real_data = real_game.join("Data");
        std::fs::create_dir_all(&real_data).unwrap();

        let game_link = tmp.path().join("game_link");
        symlink(&real_game, &game_link).unwrap();

        let mount = Path::new("/instance/VFS_FUSE");
        let translated = translate_working_dir_to_vfs(&real_data, &game_link, mount);
        assert_eq!(translated, PathBuf::from("/instance/VFS_FUSE/Data"));
    }
}
