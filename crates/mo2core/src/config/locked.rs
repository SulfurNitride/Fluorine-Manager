//! Parser/writer for MO2's `lockedorder.txt` format.
//!
//! Format:
//! - Pipe-delimited: `PluginName.esp|42`
//! - Lines starting with `#` are comments
//! - Negative priorities are rejected
//! - Line endings: `\r\n`

use std::collections::HashMap;
use std::path::Path;

/// A locked plugin order entry.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct LockedEntry {
    pub plugin: String,
    pub priority: i32,
}

/// Parsed lockedorder.txt
#[derive(Debug, Clone, Default)]
pub struct LockedOrder {
    pub entries: Vec<LockedEntry>,
}

impl LockedOrder {
    /// Parse lockedorder.txt from string content.
    pub fn parse(content: &str) -> Self {
        let mut entries = Vec::new();

        for line in content.lines() {
            let line = line.trim_end_matches('\r').trim();
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            if let Some(pipe_pos) = line.find('|') {
                let plugin = line[..pipe_pos].trim().to_string();
                if let Ok(priority) = line[pipe_pos + 1..].trim().parse::<i32>() {
                    // Reject negative priorities per MO2 behavior
                    if priority >= 0 {
                        entries.push(LockedEntry { plugin, priority });
                    }
                }
            }
        }

        LockedOrder { entries }
    }

    /// Read and parse from file.
    pub fn read(path: &Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        Ok(Self::parse(&content))
    }

    /// Write to string.
    pub fn write_to_string(&self) -> String {
        let mut out = String::new();
        out.push_str("# This file was automatically generated by Mod Organizer.\r\n");
        for entry in &self.entries {
            out.push_str(&entry.plugin);
            out.push('|');
            out.push_str(&entry.priority.to_string());
            out.push_str("\r\n");
        }
        out
    }

    /// Write to file.
    pub fn write(&self, path: &Path) -> anyhow::Result<()> {
        std::fs::write(path, self.write_to_string())?;
        Ok(())
    }

    /// Get the locked priority for a plugin (case-insensitive).
    pub fn get_priority(&self, plugin: &str) -> Option<i32> {
        let lower = plugin.to_lowercase();
        self.entries
            .iter()
            .find(|e| e.plugin.to_lowercase() == lower)
            .map(|e| e.priority)
    }

    /// Set or add a locked priority for a plugin.
    pub fn set_priority(&mut self, plugin: &str, priority: i32) {
        let lower = plugin.to_lowercase();
        if let Some(entry) = self
            .entries
            .iter_mut()
            .find(|e| e.plugin.to_lowercase() == lower)
        {
            entry.priority = priority;
        } else {
            self.entries.push(LockedEntry {
                plugin: plugin.to_string(),
                priority,
            });
        }
    }

    /// Remove a locked entry by plugin name.
    pub fn remove(&mut self, plugin: &str) -> bool {
        let lower = plugin.to_lowercase();
        let len = self.entries.len();
        self.entries.retain(|e| e.plugin.to_lowercase() != lower);
        self.entries.len() != len
    }

    /// Convert to a HashMap for quick lookups.
    pub fn to_map(&self) -> HashMap<String, i32> {
        self.entries
            .iter()
            .map(|e| (e.plugin.to_lowercase(), e.priority))
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse() {
        let content = "# Comment\r\nSkyrim.esm|0\r\nUpdate.esm|1\r\nMyMod.esp|42\r\n";
        let locked = LockedOrder::parse(content);
        assert_eq!(locked.entries.len(), 3);
        assert_eq!(locked.entries[0].plugin, "Skyrim.esm");
        assert_eq!(locked.entries[0].priority, 0);
        assert_eq!(locked.entries[2].priority, 42);
    }

    #[test]
    fn test_negative_priority_rejected() {
        let content = "Bad.esp|-1\r\nGood.esp|5\r\n";
        let locked = LockedOrder::parse(content);
        assert_eq!(locked.entries.len(), 1);
        assert_eq!(locked.entries[0].plugin, "Good.esp");
    }

    #[test]
    fn test_roundtrip() {
        let content = "# This file was automatically generated by Mod Organizer.\r\nSkyrim.esm|0\r\nMyMod.esp|42\r\n";
        let locked = LockedOrder::parse(content);
        let output = locked.write_to_string();
        let reparsed = LockedOrder::parse(&output);
        assert_eq!(locked.entries.len(), reparsed.entries.len());
        for (a, b) in locked.entries.iter().zip(reparsed.entries.iter()) {
            assert_eq!(a.plugin, b.plugin);
            assert_eq!(a.priority, b.priority);
        }
    }

    #[test]
    fn test_get_set_priority() {
        let mut locked = LockedOrder::default();
        locked.set_priority("MyMod.esp", 10);
        assert_eq!(locked.get_priority("mymod.esp"), Some(10));

        locked.set_priority("MyMod.esp", 20);
        assert_eq!(locked.get_priority("MyMod.esp"), Some(20));
        assert_eq!(locked.entries.len(), 1);
    }

    #[test]
    fn test_remove() {
        let mut locked = LockedOrder::default();
        locked.set_priority("A.esp", 1);
        locked.set_priority("B.esp", 2);
        assert!(locked.remove("a.esp"));
        assert_eq!(locked.entries.len(), 1);
        assert!(!locked.remove("nonexistent.esp"));
    }
}
