//! Parser/writer for MO2's `modlist.txt` format.
//!
//! Format:
//! - Header: `# This file was automatically generated by Mod Organizer.`
//! - One mod per line: `{prefix}{modname}`
//! - Prefixes: `+` (enabled), `-` (disabled), `*` (foreign)
//! - Lines starting with `#` are comments
//! - File is written in REVERSE priority order (first line = highest priority)
//! - Line endings: `\r\n`
//!
//! On read, priorities are inverted: line 0 gets priority (N-1), line 1 gets (N-2), etc.

use std::path::Path;

/// Status prefix for a mod in modlist.txt
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ModStatus {
    Enabled,
    Disabled,
    Foreign,
}

/// A single entry from modlist.txt
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ModListEntry {
    /// Mod directory name
    pub name: String,
    /// Whether the mod is enabled/disabled/foreign
    pub status: ModStatus,
    /// Priority (higher = wins conflicts). Assigned on read by inverting file order.
    pub priority: i32,
}

/// Parsed modlist.txt
#[derive(Debug, Clone, Default)]
pub struct ModList {
    pub entries: Vec<ModListEntry>,
}

impl ModList {
    /// Parse a modlist.txt from string content.
    ///
    /// The file is written highest-priority-first, so we invert on read:
    /// line 0 -> priority (N-1), line 1 -> priority (N-2), etc.
    pub fn parse(content: &str) -> Self {
        let mut entries = Vec::new();

        // Collect non-comment, non-empty lines first
        let lines: Vec<&str> = content
            .lines()
            .map(|l| l.trim_end_matches('\r').trim())
            .filter(|l| !l.is_empty() && !l.starts_with('#'))
            .collect();

        let total = lines.len() as i32;

        for (idx, line) in lines.iter().enumerate() {
            let (status, name) = if let Some(rest) = line.strip_prefix('+') {
                (ModStatus::Enabled, rest.to_string())
            } else if let Some(rest) = line.strip_prefix('-') {
                (ModStatus::Disabled, rest.to_string())
            } else if let Some(rest) = line.strip_prefix('*') {
                (ModStatus::Foreign, rest.to_string())
            } else {
                // Legacy format: no prefix means enabled
                (ModStatus::Enabled, line.to_string())
            };

            // Invert priority: first line in file = highest priority
            let priority = total - 1 - idx as i32;

            entries.push(ModListEntry {
                name,
                status,
                priority,
            });
        }

        ModList { entries }
    }

    /// Read and parse modlist.txt from a file path.
    pub fn read(path: &Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        Ok(Self::parse(&content))
    }

    /// Write modlist.txt to string.
    ///
    /// Entries are written in descending priority order (highest first).
    pub fn write_to_string(&self) -> String {
        let mut out = String::new();
        out.push_str("# This file was automatically generated by Mod Organizer.\r\n");

        // Sort by priority descending for output
        let mut sorted: Vec<&ModListEntry> = self.entries.iter().collect();
        sorted.sort_by(|a, b| b.priority.cmp(&a.priority));

        for entry in sorted {
            let prefix = match entry.status {
                ModStatus::Enabled => "+",
                ModStatus::Disabled => "-",
                ModStatus::Foreign => "*",
            };
            out.push_str(prefix);
            out.push_str(&entry.name);
            out.push_str("\r\n");
        }

        out
    }

    /// Write modlist.txt to a file.
    pub fn write(&self, path: &Path) -> anyhow::Result<()> {
        let content = self.write_to_string();
        std::fs::write(path, &content)?;
        Ok(())
    }

    /// Get an entry by mod name (case-insensitive).
    pub fn find(&self, name: &str) -> Option<&ModListEntry> {
        let lower = name.to_lowercase();
        self.entries.iter().find(|e| e.name.to_lowercase() == lower)
    }

    /// Get a mutable entry by mod name (case-insensitive).
    pub fn find_mut(&mut self, name: &str) -> Option<&mut ModListEntry> {
        let lower = name.to_lowercase();
        self.entries
            .iter_mut()
            .find(|e| e.name.to_lowercase() == lower)
    }

    /// Get only enabled entries, sorted by priority ascending.
    pub fn enabled_sorted(&self) -> Vec<&ModListEntry> {
        let mut enabled: Vec<&ModListEntry> = self
            .entries
            .iter()
            .filter(|e| e.status == ModStatus::Enabled)
            .collect();
        enabled.sort_by_key(|e| e.priority);
        enabled
    }

    /// Check if a mod name represents a separator (ends with `_separator`).
    pub fn is_separator(name: &str) -> bool {
        let lower = name.to_lowercase();
        lower.ends_with("_separator") || lower == "_separator" || lower.starts_with("_separator_")
    }

    /// Get the display name for a mod (strips `_separator` suffix for separators).
    pub fn display_name(name: &str) -> &str {
        if !Self::is_separator(name) {
            return name;
        }

        let lower = name.to_lowercase();
        if lower.starts_with("_separator_") {
            return &name["_separator_".len()..];
        }
        if lower == "_separator" {
            return "Separator";
        }
        if let Some(suffix_start) = lower.rfind("_separator") {
            return &name[..suffix_start];
        }

        name
    }

    /// Build a separator entry name using the common Windows MO2 form.
    ///
    /// Windows MO2 lists typically use `<DisplayName>_separator`.
    pub fn separator_entry_name(display_name: &str) -> String {
        let trimmed = display_name.trim();
        if trimmed.is_empty() {
            "Separator_separator".to_string()
        } else {
            format!("{trimmed}_separator")
        }
    }

    /// Set the enabled/disabled status of a mod by name.
    /// If the mod is not in the list, it is added at the end (highest priority).
    pub fn set_enabled(&mut self, name: &str, enabled: bool) -> bool {
        if let Some(entry) = self.find_mut(name) {
            entry.status = if enabled {
                ModStatus::Enabled
            } else {
                ModStatus::Disabled
            };
            true
        } else {
            // Mod not in the list yet (newly discovered on disk) â€” add it
            let max_priority = self.entries.iter().map(|e| e.priority).max().unwrap_or(-1);
            self.entries.push(ModListEntry {
                name: name.to_string(),
                status: if enabled {
                    ModStatus::Enabled
                } else {
                    ModStatus::Disabled
                },
                priority: max_priority + 1,
            });
            true
        }
    }

    /// Reassign priorities after reordering. Input is names in desired priority order
    /// (index 0 = priority 0, index N-1 = priority N-1).
    pub fn reorder(&mut self, names_ascending_priority: &[&str]) {
        for (new_priority, name) in names_ascending_priority.iter().enumerate() {
            if let Some(entry) = self.find_mut(name) {
                entry.priority = new_priority as i32;
            }
        }
    }

    /// Total number of regular (non-foreign) mods.
    pub fn regular_count(&self) -> usize {
        self.entries
            .iter()
            .filter(|e| e.status != ModStatus::Foreign)
            .count()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const SAMPLE_MODLIST: &str = "\
# This file was automatically generated by Mod Organizer.\r\n\
+HighPriorityMod\r\n\
-DisabledMod\r\n\
+MediumPriorityMod\r\n\
*ForeignMod\r\n\
+LowPriorityMod\r\n";

    #[test]
    fn test_parse() {
        let modlist = ModList::parse(SAMPLE_MODLIST);
        assert_eq!(modlist.entries.len(), 5);

        // First line (HighPriorityMod) should have highest priority
        let high = modlist.find("HighPriorityMod").unwrap();
        assert_eq!(high.status, ModStatus::Enabled);
        assert_eq!(high.priority, 4); // 5 entries, index 0 -> priority 4

        let disabled = modlist.find("DisabledMod").unwrap();
        assert_eq!(disabled.status, ModStatus::Disabled);
        assert_eq!(disabled.priority, 3);

        let medium = modlist.find("MediumPriorityMod").unwrap();
        assert_eq!(medium.status, ModStatus::Enabled);
        assert_eq!(medium.priority, 2);

        let foreign = modlist.find("ForeignMod").unwrap();
        assert_eq!(foreign.status, ModStatus::Foreign);
        assert_eq!(foreign.priority, 1);

        let low = modlist.find("LowPriorityMod").unwrap();
        assert_eq!(low.status, ModStatus::Enabled);
        assert_eq!(low.priority, 0);
    }

    #[test]
    fn test_roundtrip() {
        let modlist = ModList::parse(SAMPLE_MODLIST);
        let output = modlist.write_to_string();
        let reparsed = ModList::parse(&output);

        assert_eq!(modlist.entries.len(), reparsed.entries.len());
        for (a, b) in modlist.entries.iter().zip(reparsed.entries.iter()) {
            assert_eq!(a.name, b.name);
            assert_eq!(a.status, b.status);
            assert_eq!(a.priority, b.priority);
        }
    }

    #[test]
    fn test_enabled_sorted() {
        let modlist = ModList::parse(SAMPLE_MODLIST);
        let enabled = modlist.enabled_sorted();
        // HighPriorityMod(+), MediumPriorityMod(+), LowPriorityMod(+) = 3 enabled
        // DisabledMod(-) and ForeignMod(*) are excluded
        assert_eq!(enabled.len(), 3);
        // Should be sorted ascending by priority
        assert_eq!(enabled[0].name, "LowPriorityMod");
        assert_eq!(enabled[1].name, "MediumPriorityMod");
        assert_eq!(enabled[2].name, "HighPriorityMod");
    }

    #[test]
    fn test_separator_detection() {
        assert!(ModList::is_separator("My Section_separator"));
        assert!(ModList::is_separator("UI Mods_SEPARATOR"));
        assert!(ModList::is_separator("_separator_Visuals"));
        assert!(ModList::is_separator("_separator"));
        assert!(!ModList::is_separator("Regular Mod"));
    }

    #[test]
    fn test_display_name() {
        assert_eq!(ModList::display_name("UI Mods_separator"), "UI Mods");
        assert_eq!(ModList::display_name("_separator_Visuals"), "Visuals");
        assert_eq!(ModList::display_name("_separator"), "Separator");
        assert_eq!(ModList::display_name("Regular Mod"), "Regular Mod");
    }

    #[test]
    fn test_separator_entry_name() {
        assert_eq!(
            ModList::separator_entry_name("Visuals"),
            "Visuals_separator"
        );
        assert_eq!(ModList::separator_entry_name(""), "Separator_separator");
    }

    #[test]
    fn test_set_enabled() {
        let mut modlist = ModList::parse(SAMPLE_MODLIST);
        assert!(modlist.set_enabled("DisabledMod", true));
        let entry = modlist.find("DisabledMod").unwrap();
        assert_eq!(entry.status, ModStatus::Enabled);
    }

    #[test]
    fn test_crlf_line_endings() {
        let output = ModList::parse(SAMPLE_MODLIST).write_to_string();
        assert!(output.contains("\r\n"));
        assert!(!output.contains('\n') || output.replace("\r\n", "").find('\n').is_none());
    }

    #[test]
    fn test_legacy_no_prefix() {
        let content = "# Comment\r\nSomeMod\r\n";
        let modlist = ModList::parse(content);
        assert_eq!(modlist.entries.len(), 1);
        assert_eq!(modlist.entries[0].status, ModStatus::Enabled);
        assert_eq!(modlist.entries[0].name, "SomeMod");
    }
}
