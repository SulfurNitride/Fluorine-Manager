//! Parser/writer for MO2's `plugins.txt` and `loadorder.txt` formats.
//!
//! ## plugins.txt format:
//! - One plugin per line
//! - `*PluginName.esp` means enabled (star prefix)
//! - `PluginName.esp` (no star) means present but disabled
//! - Lines starting with `#` are comments
//! - Line endings: `\r\n`
//!
//! ## loadorder.txt format:
//! - One plugin per line (no prefix - just the filename)
//! - Order = load order (first line = loaded first)
//! - Line endings: `\r\n`

use std::path::Path;

/// A plugin entry from plugins.txt
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct PluginEntry {
    /// Plugin filename (e.g., `Skyrim.esm`, `MyMod.esp`)
    pub filename: String,
    /// Whether the plugin is enabled
    pub enabled: bool,
}

/// Parsed plugins.txt
#[derive(Debug, Clone, Default)]
pub struct PluginsTxt {
    pub entries: Vec<PluginEntry>,
}

impl PluginsTxt {
    /// Parse plugins.txt from string content.
    pub fn parse(content: &str) -> Self {
        let mut entries = Vec::new();

        for line in content.lines() {
            let line = line.trim_end_matches('\r').trim();
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            let (enabled, filename) = if let Some(rest) = line.strip_prefix('*') {
                (true, rest.to_string())
            } else {
                (false, line.to_string())
            };

            entries.push(PluginEntry { filename, enabled });
        }

        PluginsTxt { entries }
    }

    /// Read and parse from file.
    pub fn read(path: &Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        Ok(Self::parse(&content))
    }

    /// Write to string.
    pub fn write_to_string(&self) -> String {
        let mut out = String::new();
        out.push_str("# This file was automatically generated by Mod Organizer.\r\n");
        for entry in &self.entries {
            if entry.enabled {
                out.push('*');
            }
            out.push_str(&entry.filename);
            out.push_str("\r\n");
        }
        out
    }

    /// Write to file.
    pub fn write(&self, path: &Path) -> anyhow::Result<()> {
        std::fs::write(path, self.write_to_string())?;
        Ok(())
    }

    /// Find a plugin by filename (case-insensitive).
    pub fn find(&self, filename: &str) -> Option<&PluginEntry> {
        let lower = filename.to_lowercase();
        self.entries
            .iter()
            .find(|e| e.filename.to_lowercase() == lower)
    }

    /// Find a plugin by filename (case-insensitive, mutable).
    pub fn find_mut(&mut self, filename: &str) -> Option<&mut PluginEntry> {
        let lower = filename.to_lowercase();
        self.entries
            .iter_mut()
            .find(|e| e.filename.to_lowercase() == lower)
    }

    /// Set enabled state for a plugin.
    pub fn set_enabled(&mut self, filename: &str, enabled: bool) -> bool {
        if let Some(entry) = self.find_mut(filename) {
            entry.enabled = enabled;
            true
        } else {
            false
        }
    }

    /// Get enabled plugins in order.
    pub fn enabled(&self) -> Vec<&PluginEntry> {
        self.entries.iter().filter(|e| e.enabled).collect()
    }
}

/// Parsed loadorder.txt - just an ordered list of plugin filenames.
#[derive(Debug, Clone, Default)]
pub struct LoadOrder {
    pub plugins: Vec<String>,
}

impl LoadOrder {
    /// Parse loadorder.txt from string content.
    pub fn parse(content: &str) -> Self {
        let plugins = content
            .lines()
            .map(|l| l.trim_end_matches('\r').trim().to_string())
            .filter(|l| !l.is_empty() && !l.starts_with('#'))
            .collect();
        LoadOrder { plugins }
    }

    /// Read and parse from file.
    pub fn read(path: &Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        Ok(Self::parse(&content))
    }

    /// Write to string.
    pub fn write_to_string(&self) -> String {
        let mut out = String::new();
        out.push_str("# This file was automatically generated by Mod Organizer.\r\n");
        for plugin in &self.plugins {
            out.push_str(plugin);
            out.push_str("\r\n");
        }
        out
    }

    /// Write to file.
    pub fn write(&self, path: &Path) -> anyhow::Result<()> {
        std::fs::write(path, self.write_to_string())?;
        Ok(())
    }

    /// Get the load index for a plugin (case-insensitive).
    pub fn index_of(&self, filename: &str) -> Option<usize> {
        let lower = filename.to_lowercase();
        self.plugins.iter().position(|p| p.to_lowercase() == lower)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_plugins_txt_parse() {
        let content =
            "# Comment\r\n*Skyrim.esm\r\n*Update.esm\r\nOptionalMod.esp\r\n*MyMod.esp\r\n";
        let plugins = PluginsTxt::parse(content);
        assert_eq!(plugins.entries.len(), 4);

        assert_eq!(plugins.entries[0].filename, "Skyrim.esm");
        assert!(plugins.entries[0].enabled);

        assert_eq!(plugins.entries[2].filename, "OptionalMod.esp");
        assert!(!plugins.entries[2].enabled);
    }

    #[test]
    fn test_plugins_txt_roundtrip() {
        let content = "# This file was automatically generated by Mod Organizer.\r\n*Skyrim.esm\r\n*Update.esm\r\nOptionalMod.esp\r\n*MyMod.esp\r\n";
        let plugins = PluginsTxt::parse(content);
        let output = plugins.write_to_string();
        let reparsed = PluginsTxt::parse(&output);

        assert_eq!(plugins.entries.len(), reparsed.entries.len());
        for (a, b) in plugins.entries.iter().zip(reparsed.entries.iter()) {
            assert_eq!(a.filename, b.filename);
            assert_eq!(a.enabled, b.enabled);
        }
    }

    #[test]
    fn test_loadorder_parse() {
        let content = "# Comment\r\nSkyrim.esm\r\nUpdate.esm\r\nMyMod.esp\r\n";
        let lo = LoadOrder::parse(content);
        assert_eq!(lo.plugins.len(), 3);
        assert_eq!(lo.plugins[0], "Skyrim.esm");
        assert_eq!(lo.index_of("update.esm"), Some(1));
    }

    #[test]
    fn test_enabled_filter() {
        let content = "*Skyrim.esm\r\nDisabled.esp\r\n*Enabled.esp\r\n";
        let plugins = PluginsTxt::parse(content);
        let enabled = plugins.enabled();
        assert_eq!(enabled.len(), 2);
        assert_eq!(enabled[0].filename, "Skyrim.esm");
        assert_eq!(enabled[1].filename, "Enabled.esp");
    }
}
