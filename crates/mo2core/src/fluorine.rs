//! Fluorine Manager - global prefix management
//!
//! Manages a single shared Wine/Proton prefix for all MO2 instances.
//! Config stored at `~/.config/fluorine/config.json`.

use std::fs;
use std::path::PathBuf;

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};

/// Fluorine config file location: `~/.config/fluorine/config.json`
fn config_path() -> PathBuf {
    let home = std::env::var("HOME").unwrap_or_else(|_| String::from("/tmp"));
    PathBuf::from(home).join(".config/fluorine/config.json")
}

/// Persistent config for the global Fluorine prefix.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FluorineConfig {
    /// Steam shortcut AppID (generated by NaK when creating the shortcut)
    pub app_id: u32,
    /// Path to the Wine prefix (`steamapps/compatdata/<appid>/pfx`)
    pub prefix_path: String,
    /// Proton config name used (e.g. "GE-Proton10-1")
    pub proton_name: String,
    /// Proton installation path
    pub proton_path: String,
    /// Timestamp of creation
    pub created: String,
}

impl FluorineConfig {
    /// Load config from disk. Returns None if not yet set up.
    pub fn load() -> Option<Self> {
        let path = config_path();
        let content = fs::read_to_string(&path).ok()?;
        serde_json::from_str(&content).ok()
    }

    /// Save config to disk.
    pub fn save(&self) -> Result<()> {
        let path = config_path();
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent).context("Failed to create ~/.config/fluorine/")?;
        }
        let json = serde_json::to_string_pretty(self).context("Failed to serialize config")?;
        fs::write(&path, json).context("Failed to write config")?;
        Ok(())
    }

    /// Delete config file from disk.
    pub fn delete() -> Result<()> {
        let path = config_path();
        if path.exists() {
            fs::remove_file(&path).context("Failed to remove config")?;
        }
        Ok(())
    }

    /// Check if the prefix directory actually exists on disk.
    pub fn prefix_exists(&self) -> bool {
        let pfx = PathBuf::from(&self.prefix_path);
        pfx.join("drive_c").exists()
    }

    /// Get the compatdata directory (parent of pfx/).
    pub fn compat_data_path(&self) -> PathBuf {
        PathBuf::from(&self.prefix_path)
            .parent()
            .map(|p| p.to_path_buf())
            .unwrap_or_else(|| PathBuf::from(&self.prefix_path))
    }

    /// Delete the prefix from disk and remove the config.
    pub fn destroy_prefix(&self) -> Result<()> {
        let compat_data = self.compat_data_path();
        if compat_data.exists() {
            fs::remove_dir_all(&compat_data)
                .with_context(|| format!("Failed to delete prefix at {}", compat_data.display()))?;
        }
        Self::delete()?;
        Ok(())
    }
}

/// Check if Fluorine has been set up (prefix exists).
pub fn is_setup() -> bool {
    FluorineConfig::load().is_some_and(|c| c.prefix_exists())
}

/// Get the current prefix path if set up.
pub fn prefix_path() -> Option<PathBuf> {
    FluorineConfig::load()
        .filter(|c| c.prefix_exists())
        .map(|c| PathBuf::from(c.prefix_path))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_config_roundtrip() {
        let config = FluorineConfig {
            app_id: 12345,
            prefix_path: "/home/user/.steam/steam/steamapps/compatdata/12345/pfx".to_string(),
            proton_name: "GE-Proton10-1".to_string(),
            proton_path: "/home/user/.steam/steam/compatibilitytools.d/GE-Proton10-1".to_string(),
            created: "2025-01-01T00:00:00Z".to_string(),
        };

        let json = serde_json::to_string_pretty(&config).unwrap();
        let parsed: FluorineConfig = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed.app_id, 12345);
        assert_eq!(parsed.proton_name, "GE-Proton10-1");
    }

    #[test]
    fn test_compat_data_path() {
        let config = FluorineConfig {
            app_id: 12345,
            prefix_path: "/steam/steamapps/compatdata/12345/pfx".to_string(),
            proton_name: String::new(),
            proton_path: String::new(),
            created: String::new(),
        };
        assert_eq!(
            config.compat_data_path(),
            PathBuf::from("/steam/steamapps/compatdata/12345")
        );
    }

    #[test]
    fn test_prefix_exists_false() {
        let config = FluorineConfig {
            app_id: 99999,
            prefix_path: "/nonexistent/path/pfx".to_string(),
            proton_name: String::new(),
            proton_path: String::new(),
            created: String::new(),
        };
        assert!(!config.prefix_exists());
    }
}
